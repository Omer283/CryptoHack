import numpy as np
def ext_gcd(a, b):
    if b == 0:
        return a, 1, 0
    else:
        g, y, x = ext_gcd(b, a % b)
        y -= (a // b) * x
        return g, x, y


def inv(x, p):
    return ext_gcd(x, p)[1]


def bpw(a, k, p):
    base = a
    cur = 1
    while k != 0:
        if k % 2 == 1:
            cur *= base
            cur %= p
        base *= base
        base %= p
        k >>= 1
    return cur


def legendre_slow(a, p):
    ret = bpw(a, (p - 1) // 2, p)
    if ret < 0:
        ret += p
    return ret if ret == 1 else -1


def modular_sqrt(a, p):
    if legendre_slow(a, p) != 1:
        return 0
    elif a == 0:
        return 0
    elif p == 2:
        return p
    elif p % 4 == 3:
        return bpw(a, (p + 1) // 4, p)
    s = p - 1
    e = 0
    while s % 2 == 0:
        s //= 2
        e += 1
    n = 2
    while legendre_slow(n, p) == 1:
        n += 1
    x = bpw(a, (s + 1) // 2, p)
    b = bpw(a, s, p)
    g = bpw(n, s, p)
    r = e
    while True:
        t = b
        m = 0
        for m in range(r):
            if t == 1:
                break
            t = bpw(t, 2, p)
        if m == 0:
            return x
        gs = bpw(g, 2 ** (r - m - 1), p)
        g = (gs * gs) % p
        x = (x * gs) % p
        b = (b * g) % p
        r = m


def crt_two(a1, a2, m1, m2):
    mul = m1 * m2
    x = a2 * inv(m1, m2) * m1 + a1 * inv(m2, m1) * m2
    x %= mul
    if x < 0:
        x += mul
    return x, mul


def crt(a: list, m: list):
    n = len(a)
    if n == 1:
        return a[0], m[0]
    ca, cm = crt_two(a[0], a[1], m[0], m[1])
    for i in range(2, n):
        ca, cm = crt_two(ca, a[i], cm, m[i])
    return ca, cm


def gs(v):
    n = len(v)
    d = len(v[0])
    u = []
    u.append(v[0])
    for i in range(1, n):
        vec = 0
        for j in range(i):
            mu = np.dot(v[i], u[j] / (np.linalg.norm(u[j]) ** 2))
            vec += mu * u[j]
        u.append(v[i] - vec)
    return np.array(u)


def gauss_reduction(u, v):
    while True:
        if np.linalg.norm(v) < np.linalg.norm(u):
            u, v = v, u
        m = np.dot(u, v) // np.dot(u, u)
        if m == 0:
            return u, v
        v = np.subtract(v, m * u)
